{"version":3,"file":"react-router-manage.production.min.js","sources":["../src/components/NoAuth/index.tsx","../src/components/NameRedirect/index.tsx","../src/components/Spin/index.tsx","../src/changeable.tsx","../src/GeneratorHookCom.tsx","../src/util.tsx","../src/components/NotFound/index.tsx","../src/getInitialState.ts","../src/Context/MRouterHistoryContext.tsx","../src/BrowserRouter.tsx","../src/HashRouter.tsx","../src/type.ts","../src/actions.ts","../src/Context/MRouterContext.tsx","../src/index.tsx"],"sourcesContent":["import * as React from 'react';\n\nconst PageConfig = {\n  '401': {\n    title: '无权限查看该页面',\n    img: '//ysf.qiyukf.net/yx/9c9ce7793b3c0657da5d80e740a89681',\n  },\n  '404': {\n    title: '页面不存在',\n    img: 'https://ysf.nosdn.127.net/ysh/6be90dea7806767fe65e7b48982b7a61',\n  },\n} as Record<string, {title: string; img: string}>;\n\nconst NoAuth: React.FC<{ code?: string }> = ({ code = '401' }) => {\n  const config = PageConfig[code];\n  return (\n    <div\n      style={{\n        display: 'flex',\n        justifyContent: 'center',\n        alignItems: 'center',\n        background: 'white',\n        height: '100%',\n        flexDirection: 'column',\n        borderRadius: 8,\n      }}\n    >\n      <img alt={config.title} width={200} src={config?.img} />\n      <div\n        style={{ color: '#666666', lineHeight: '22px', textAlign: 'center', marginTop: 16 }}\n      >\n        {config.title}\n      </div>\n    </div>\n  );\n};\n\nNoAuth.displayName = 'NoAuth';\n\nexport default NoAuth;\n","import * as React from 'react';\nimport { Navigate } from 'react-router-dom';\nimport { useRouter } from '../../index';\n\nconst NameRedirect: React.FC<{ name: string; component?: React.ComponentType<any> }> = ({ name, component: Component }) => {\n  const { routesMap, currentRoute } = useRouter();\n\n  const targetRoute = routesMap[name];\n\n  if (!targetRoute) {\n    if (__DEV__) {\n      Error(`routesMap.${name} 路由不存在`);\n    }\n  }\n\n  if (name === currentRoute.name) {\n    if (Component) {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-expect-error\n      return <Component />;\n    }\n    return <></>;\n  }\n\n  return <Navigate to={targetRoute.path || ''} />;\n};\n\nexport default NameRedirect;\n","import * as React from 'react';\nconst Spin:React.FC<{tip: string}> = ({tip = \"加载中\"})  => {\n  return <div>{tip}</div>;\n}\n\nexport default Spin;\n","import * as React from 'react';\nimport Spin from './components/Spin'\nconst LoadingCmp = () => <><Spin tip=\"应用正在加载中…\" /></>;\n\n/**\n * LoadingComponent Define the Suspense component's fallback and beforeEnter when a component is loaded, \n * and the state component when calling next\n */\ninterface ChangeableI {\n    LoadingComponent: React.FunctionComponent<any>\n}\n\nconst changeable: ChangeableI = {\n    LoadingComponent: LoadingCmp,\n}\n\nfunction setChangeable(options: Partial<ChangeableI>) {\n    Object.entries(options).forEach(([key , value]) => {\n        changeable[key as keyof ChangeableI] = value\n    })\n}\n\nexport {\n    changeable,\n    setChangeable\n}","import * as React from \"react\";\nimport { useLayoutEffect, useState } from \"react\";\nimport { Navigate } from \"react-router-dom\";\nimport NameRedirect from \"./components/NameRedirect\";\nimport type {\n  BeforeEachMountI,\n  BeforeEnterI,\n  NextOptionsType,\n  RouteTypeI\n} from \"./type\";\n\nimport { useRouter } from \"./index\";\nimport { isComponent, isString } from \"./util\";\nimport { changeable } from \"./changeable\";\n\nfunction getComponent(\n  options?: NextOptionsType,\n  Component?: React.ComponentType\n) {\n  let ReplaceComponent: React.ComponentType<any> | undefined;\n  if (!options) {\n    return ReplaceComponent;\n  }\n  // if a component is passed in\n  if (isComponent(options)) {\n    ReplaceComponent = options as React.ComponentType<any>;\n    // @ts-ignore\n  } else if (isString(options.path)) {\n    // if there is path, path is preferred\n    ReplaceComponent = function Redirect() {\n      // @ts-ignore\n      return <Navigate to={options.path!} />;\n    };\n     // @ts-ignore\n  } else if (isString(options.name)) {\n    // if there is no path, use name\n    ReplaceComponent = function Redirect() {\n      // @ts-ignore\n      return <NameRedirect name={options.name!} component={Component} />;\n    };\n  }\n  return ReplaceComponent;\n}\n\nexport const GeneratorHookCom: React.FC<{\n  beforeEnter?: BeforeEnterI;\n  beforeEachMount?: BeforeEachMountI;\n  Component: any;\n  _route: RouteTypeI;\n}> = ({ beforeEnter, Component, beforeEachMount }) => {\n  /**\n   * since setCurrentComponent(Component) Component may be a function\n   * react by default, if the preState is a function, the function will be executed and an error will occur\n   * So here we put Component into an object\n   */\n  const [CurrentComponent, setCurrentComponent] = useState<{ Component: any }>({\n    Component: undefined\n  });\n  const { currentRoute } = useRouter();\n  useLayoutEffect(() => {\n    // 是否激活状态(未卸载)\n    let isActive = true;\n    // 全局的\n    if (beforeEachMount) {\n      beforeEachMount(currentRoute, options => {\n        if (!isActive) {\n          return;\n        }\n\n        // global\n        const EachReplaceComponent = getComponent(options, Component);\n        if (beforeEnter) {\n          // local\n          beforeEnter(currentRoute, enterOptions => {\n            if (!isActive) {\n              return;\n            }\n            const EnterReplaceComponent = getComponent(\n              enterOptions,\n              EachReplaceComponent || Component\n            );\n            // if the Component is passed in next in beforeEnter, the beforeEnter shall prevail\n\n            // Otherwise, beforeEachBeforeMount shall prevail\n            setCurrentComponent({\n              Component:\n                EnterReplaceComponent || EachReplaceComponent || Component\n            });\n          });\n        } else {\n          setCurrentComponent({ Component: EachReplaceComponent || Component });\n        }\n      });\n    } else {\n      // local\n      if (beforeEnter) {\n        beforeEnter(currentRoute, enterOptions => {\n          if (!isActive) {\n            return;\n          }\n          const EnterReplaceComponent = getComponent(enterOptions, Component);\n          setCurrentComponent({\n            Component: EnterReplaceComponent || Component\n          });\n        });\n      }\n    }\n    return () => {\n      isActive = false;\n    };\n  }, [Component, currentRoute, beforeEnter, beforeEachMount]);\n  const LoadingCmp = changeable.LoadingComponent;\n  return CurrentComponent.Component ? (\n    <CurrentComponent.Component />\n  ) : (\n    <LoadingCmp />\n  );\n};\n\nexport default GeneratorHookCom;\n","import * as React from 'react';\nimport type { To } from 'react-router';\nimport { Navigate } from 'react-router';\nimport NoAuth from './components/NoAuth';\nimport type {\n  BeforeEachMountI,\n  CodeType,\n  FnCodeType,\n  PermissionListType,\n  RouteCbI,\n  RouteEvent,\n  RouteTypeExtendsI,\n  RouteTypeI,\n  RouteTypeInputI,\n  RouteTypePropsI,\n  RouterConfigI,\n  RoutesMapI,\n  RouterBaseConfigI,\n  NewStateQueryI,\n  NewStateI,\n} from './type';\nimport GeneratorHookCom from './GeneratorHookCom';\nimport NotFound from './components/NotFound';\nimport { setChangeable } from './changeable';\n\nlet incrementKey = 1;\nconst getIncrementName = () => {\n  const name = `__routerName${incrementKey}`;\n  incrementKey = incrementKey + 1;\n  return name;\n};\n\nfunction getWholePath (path: string, basename = '/', parentPath?: string): string {\n  if (path.startsWith(basename)) {\n    return path;\n  }\n  // 根路径\n  if (path === basename) {\n    return basename;\n  }\n\n  if (path.startsWith('/')) {\n    if (basename.endsWith('/')) {\n      return `${basename}${path.slice(1)}`;\n    }\n    return `${basename}${path}`;\n  }\n\n  if (parentPath) {\n    return getWholePath(path, parentPath);\n  }\n\n  if (basename.endsWith('/')) {\n    return `${basename}${path}`;\n  }\n  return `${basename}/${path}`;\n}\n\nexport function cloneRoutes (_routeConfig: {\n  routes: RouteTypeI[]\n  parent?: RouteTypeInputI\n  basename?: string\n  _level?: number\n}): RouteTypeInputI[] {\n  const { routes, parent, basename = '/', _level = 1 } = _routeConfig;\n  if (!routes) {\n    return [];\n  }\n  if (!Array.isArray(routes)) {\n    Error('MRouter route prop need to type Array<RouteTypeI>');\n  }\n  function _cloneRoutes (_routes: RouteTypeI[], parent?: RouteTypeInputI, _level = 1): RouteTypeInputI[] {\n    return _routes.map(_route => {\n      const { path, items, children, ...resets } = _route;\n      const wholePath = getWholePath(path, basename, parent?.path);\n      const newRoute: RouteTypeInputI = {\n        ...resets,\n        path: getValidPathname(wholePath),\n        parent,\n        _level,\n        _relativePath: path,\n      };\n      if (items) {\n        newRoute.items = _cloneRoutes(items, newRoute, _level + 1);\n      }\n      if (children) {\n        newRoute.children = _cloneRoutes(children, newRoute, _level + 1);\n      }\n\n      return newRoute;\n    });\n  }\n  return _cloneRoutes(routes, parent, _level);\n}\n\n/**\n *cCalculate some state data\n * @param inputRoutes\n * @param permissionList\n * @returns\n */\nexport function computedNewState (config: NewStateQueryI):NewStateI {\n  const { inputRoutes, permissionList, hasAuth, beforeEachMount, basename, location } = config;\n  const authInputRoutes = computeRoutesConfig({\n    routes: inputRoutes,\n    permissionList,\n    hasAuth,\n    beforeEachMount,\n  });\n  const flattenRoutes = flattenRoutesFn(authInputRoutes, undefined, true);\n  // mixin into the notFound page\n  mixinNotFoundPage(flattenRoutes, basename, authInputRoutes);\n  const routesMap = routesMapFn(flattenRoutes);\n  const currentRoute = getCurrentRoute(location.pathname, routesMap);\n  const currentPathRoutes = getCurrentPathRoutes(currentRoute);\n \n  return {\n    authInputRoutes,\n    flattenRoutes,\n    routesMap,\n    currentRoute,\n    currentPathRoutes,\n    beforeEachMount,\n  };\n}\n\n/**\n * flatten the react router array recursively\n * whether all is true, includes sub routes\n */\nexport const flattenRoutesFn = (\n  arr: RouteTypeExtendsI[],\n  parent?: RouteTypeExtendsI,\n  all?: boolean\n): RouteTypeExtendsI[] => {\n  return arr.reduce((prev: RouteTypeExtendsI[], nextRoute: RouteTypeExtendsI) => {\n    if (parent) {\n      nextRoute.parent = parent;\n    }\n    if (Array.isArray(nextRoute.items) || Array.isArray(nextRoute.children)) {\n      let _routes = prev.concat(nextRoute);\n      if (Array.isArray(nextRoute.items)) {\n        _routes = _routes.concat(flattenRoutesFn(nextRoute.items, nextRoute, all));\n      }\n      if (Array.isArray(nextRoute.children) && all) {\n        _routes = _routes.concat(flattenRoutesFn(nextRoute.children, nextRoute, all));\n      }\n      return _routes;\n    } else {\n      return prev.concat(nextRoute);\n    }\n  }, []);\n};\n\n// name => mapping of route\nexport const routesMapFn = (flattenRoutes: RouteTypeExtendsI[]): RoutesMapI => {\n  const routesMap = flattenRoutes.reduce(\n    (_routeMap: RoutesMapI, nextRoute: RouteTypeExtendsI) => {\n      const { name, path } = nextRoute;\n      if (_routeMap[name] || _routeMap[path]) {\n\n        throw new Error(`route config name or path isn't unique, route name: \"${name}\", route path: \"${path}\"`);\n      }\n      // the route has params\n      // stored internally '__paramsRoutes' variable\n      if (path.includes(':')) {\n        const _path = path.replace(/:(\\w+)/g, () => {\n          return '([^\\\\/]+)';\n        });\n        _routeMap.__paramsRoutesMap[_path] = nextRoute;\n      }\n      _routeMap[name] = _routeMap[path] = nextRoute;\n      return _routeMap;\n    },\n    {\n      __paramsRoutesMap: {},\n      __flattenRoutes: [] as RouteTypeExtendsI[],\n    } as RoutesMapI\n  );\n  routesMap.__flattenRoutes = flattenRoutes;\n  return routesMap;\n};\n\n// convert '/a/b/c/' to '/a/b/c'\nfunction getValidPathname (pathname: string) {\n  if (!pathname) {\n    return pathname;\n  }\n  if (pathname.endsWith('/')) {\n    return pathname.slice(0, -1);\n  }\n  return pathname;\n}\n\n/** find the current route object through the path */\nexport function getCurrentRoute (\n  pathname = window.location.pathname,\n  routesMap: RoutesMapI\n) {\n  // console.log(routesMap);\n  // first look from the outermost routesMap\n  pathname = getValidPathname(pathname);\n  let currentRoute = routesMap[pathname];\n  // if can't find it, go to find to routesMap.__paramsRoutesMap\n  if (!currentRoute) {\n    const paths = Object.keys(routesMap.__paramsRoutesMap);\n    let pathIndex = 0;\n    while (!currentRoute && pathIndex < paths.length) {\n      const pathPattern = new RegExp(paths[pathIndex]);\n      if (pathname.match(pathPattern)) {\n        currentRoute = routesMap.__paramsRoutesMap[paths[pathIndex]];\n        break;\n      }\n      pathIndex = pathIndex + 1;\n    }\n  }\n  // TODO 找通配符的 后续优化\n  if (!currentRoute) {\n    // 有通配符的路径\n    const paths = routesMap.__flattenRoutes.map(i => i.path).filter(i => i.endsWith('*'));\n    // find the longest one\n    let longerPath = '';\n    paths.forEach(path => {\n      path = pathStartMarkTransform(path);\n      if (!pathname.startsWith(path)) {\n        return;\n      }\n      if (path in routesMap && path.length > longerPath.length) {\n        longerPath = path;\n      }\n      // 匹配 /a/b/c*\n      let _path = `${path}*`;\n      if (_path in routesMap && _path.length > longerPath.length) {\n        longerPath = _path;\n      }\n      // 匹配 /a/b/c/*\n      _path = `${path}/*`;\n\n      if (_path in routesMap && _path.length > longerPath.length) {\n        longerPath = _path;\n      }\n\n      // 匹配 /a/b/c*\n      _path = `${pathname}*`;\n      if (_path in routesMap && _path.length > longerPath.length) {\n        longerPath = _path;\n      }\n      // 匹配 /a/b/c/*\n      _path = `${pathname}/*`;\n\n      if (_path in routesMap && _path.length > longerPath.length) {\n        longerPath = _path;\n      }\n    });\n    if (longerPath) {\n      currentRoute = routesMap[longerPath];\n    }\n  }\n  // if (!currentRoute) {\n  //   // 找父级\n\n  // }\n  if (!currentRoute) {\n    // 默认404\n    currentRoute = {\n      name: '404',\n      path: pathname,\n      title: '404',\n      _isHasAuth: false,\n      _relativePath: '',\n      _level: 0,\n      meta: {},\n      component: () => {\n        return <NoAuth />;\n      },\n    };\n  }\n  return currentRoute;\n}\n\n/**\n * 获取路由的路径（父路由和子路由的集合，主要在导航中）\n * @param currentRoute\n * @returns\n */\nexport function getCurrentPathRoutes (currentRoute: RouteTypeExtendsI) {\n  const routes: RouteTypeExtendsI[] = [];\n  let pathRoute: RouteTypeExtendsI | undefined = currentRoute;\n  while (pathRoute) {\n    routes.unshift(pathRoute);\n    pathRoute = pathRoute.parent;\n  }\n  return routes;\n}\n\nexport function executeEventCbs (option: {\n  to?: RouteTypeExtendsI\n  from?: RouteTypeExtendsI\n  callbacks: RouteCbI[]\n  finish: () => void\n}) {\n  const { to, from, callbacks, finish } = option;\n  function executeNextCb (cbIndex = 0) {\n    const nextCb = callbacks[cbIndex];\n    if (!nextCb) {\n      return finish();\n    } else {\n      nextCb.fn(to, from, () => {\n        executeNextCb(cbIndex + 1);\n      });\n    }\n  }\n  if (callbacks.length === 0) {\n    finish();\n  } else {\n    executeNextCb(0);\n  }\n}\n\nfunction getIsHasAuthByStrCode (code: string, permissionList: PermissionListType) {\n  return permissionList.includes(code);\n}\n\nfunction getIsHasAuthByFnCode (code: FnCodeType, route: RouteTypeI) {\n  return code(route);\n}\n\nexport function getIsHasAuth ({ code, permissionList, hasAuth, route }: { code: CodeType; permissionList: PermissionListType; hasAuth: boolean; route: RouteTypeI }) {\n  if (!hasAuth) { // 未配置权限\n    return true;\n  }\n  if (!code) { // 未配置code默认有权限\n    return true;\n  }\n\n  if (Array.isArray(code)) {\n    if (code.length === 0) {\n      return true;\n    }\n    return code.some(_code => {\n      return getIsHasAuthByStrCode(_code, permissionList);\n    });\n  }\n\n  if (code instanceof Function) {\n    return !!(getIsHasAuthByFnCode(code, route));\n  }\n\n  return getIsHasAuthByStrCode(code, permissionList);\n}\n\nexport function computeRoutesConfig (config: {\n  routes: RouteTypeInputI[]\n  permissionList?: string[]\n  hasAuth: boolean\n  beforeEachMount?: BeforeEachMountI\n  parent?: RouteTypeExtendsI\n}): RouteTypeExtendsI[] {\n  const { routes, permissionList = [], hasAuth, beforeEachMount, parent } = config;\n  return routes.map(route => {\n    const {\n      component: Component,\n      path,\n      code = '',\n      children,\n      items,\n      beforeEnter,\n      redirect,\n      meta,\n      type,\n      ...other\n    } = route;\n    let _children: RouteTypeExtendsI[] = [];\n    let _items: RouteTypeExtendsI[] = [];\n    let CurrentComponent = Component;\n    const props = {} as RouteTypePropsI;\n    if (beforeEnter || beforeEachMount) {\n      CurrentComponent = GeneratorHookCom;\n      props.beforeEnter = beforeEnter;\n      props.beforeEachMount = beforeEachMount;\n      props.Component = Component;\n      props.key = route.name; // users switch between routes to avoid incorrect rendering due to the same key after route switching\n      props._route = route;\n    }\n    const isHasAuth = getIsHasAuth({ code, permissionList, hasAuth, route });\n\n    const newRoute: RouteTypeExtendsI = {\n      ...route,\n      parent,\n      props,\n      meta: meta || {},\n      items: [],\n      children: [],\n      _route: route,\n      _isHasAuth: isHasAuth,\n    };\n\n    if (!isHasAuth) {\n      /**\n       * if there is no permission, the children also has no permission\n       * /a/b/c 则加入 /a/b/c/*\n       */\n      let noAuthItems: RouteTypeExtendsI[] = [];\n      if (!path.endsWith('*')) {\n        const _path = path.endsWith('/') ? `${path}*` : `${path}/*`;\n        noAuthItems = [\n          {\n            meta: {},\n            name: getIncrementName(),\n            path: _path,\n            title: '',\n            hidden: true,\n            component: NoAuth,\n            _level: other._level + 1,\n            _route: route,\n            _component: NoAuth,\n            _relativePath: '*',\n          },\n        ];\n      }\n      const returnRoute = {\n        ...newRoute,\n        items: noAuthItems,\n        children: [],\n        _component: NoAuth,\n      };\n      noAuthItems.forEach(i => {\n        i.parent = returnRoute;\n      });\n      return returnRoute;\n    }\n\n    // 处理子路由\n    if (children) {\n      _children = computeRoutesConfig({\n        routes: children,\n        permissionList,\n        hasAuth,\n        beforeEachMount,\n        parent: newRoute,\n      });\n    }\n    // 处理同级路由\n    if (items) {\n      _items = computeRoutesConfig({\n        routes: items,\n        permissionList,\n        hasAuth,\n        beforeEachMount,\n        parent: newRoute,\n      });\n    }\n    const _itemsAndChildren = [..._items, ..._children];\n    if (redirect) {\n      return {\n        ...newRoute,\n        children: _children,\n        items: _items,\n        _component: () => <Navigate to={redirect} replace={true} />,\n        _itemsAndChildren,\n      };\n    }\n    if (type === 'null') {\n      return {\n        ...newRoute,\n        children: _children,\n        items: _items,\n        _component: undefined,\n        _itemsAndChildren,\n      };\n    }\n    if (Component) {\n      return {\n        ...newRoute,\n        children: _children,\n        items: _items,\n        _component: CurrentComponent,\n        _itemsAndChildren,\n      };\n    } else {\n      const redirectPath = handleRedirectPath(route, permissionList, hasAuth);\n      if (redirectPath) {\n        let replace = false;\n        // 父级也没配置component，则会进行多次重定向进行replace, 以便浏览器回退行为\n        if (!route.parent?.component) {\n          replace = true;\n        }\n        return {\n          ...newRoute,\n          children: _children,\n          items: _items,\n          _component: () => <Navigate to={redirectPath} replace={replace} />,\n          _itemsAndChildren,\n        };\n      }\n      return {\n        ...newRoute,\n        items: [],\n        children: [],\n        _component: NoAuth,\n      };\n    }\n  });\n}\n\nexport function getCurrentRouteCbsByEvent (\n  routeEvent: RouteEvent,\n  pathname: string,\n  routeHooks: RouteCbI[]\n): RouteCbI[] {\n  return routeHooks.filter(i => {\n    return i.name === routeEvent && i.pathname === pathname;\n  });\n}\n\nfunction pathStartMarkTransform (path: string) {\n  if (path === '/') {\n    return path;\n  }\n  return path.replace(/\\/*\\**$/gm, '');\n}\n\n/**\n * when jump route，Remove the '*'\n * @param to\n * @returns\n */\nexport function getRealTo (to: To): To {\n  if (typeof to === 'string') {\n    return pathStartMarkTransform(to);\n  }\n  const { pathname } = to;\n  if (pathname) {\n    return {\n      ...to,\n      pathname: pathStartMarkTransform(pathname),\n    };\n  }\n  return to;\n}\n\nexport const handleRedirectPath = (\n  route: RouteTypeInputI,\n  permissionList: string[],\n  hasAuth: boolean\n): string => {\n  // Return to the first menu(route) item with permission\n  const { items } = route;\n  if (!items) {\n    return '';\n  }\n  // No configuration permission, return to the first one child route\n  if (!hasAuth) {\n    return items[0].path;\n  }\n  let redirectPath = '';\n  // find the first one route with permission\n  for (let i = 0; i < items?.length; i++) {\n    const childRoute = items[i];\n    const { code, path } = childRoute;\n    if (!code) {\n      // if code is false, the default is permission\n      redirectPath = path;\n      break;\n    }\n\n    if (getIsHasAuth({ code, permissionList, hasAuth, route: childRoute })) {\n      redirectPath = path;\n      break;\n    }\n  }\n  return redirectPath;\n};\n\nexport function mixinNotFoundPage (\n  flattenRoutes: RouteTypeExtendsI[],\n  basename: string,\n  authInputRoutes: RouteTypeExtendsI[]\n) {\n  const notFoundPath = getWholePath('*', basename);\n  const hasNotFoundPage = flattenRoutes.some(({ path }) => {\n    if (path === notFoundPath) {\n      return true;\n    }\n    return false;\n  });\n  if (hasNotFoundPage) {\n    return;\n  }\n\n  const notFoundPage = {\n    name: 'notFound',\n    title: 'notFound',\n    meta: {},\n    path: notFoundPath,\n    component: NotFound,\n    _component: NotFound,\n    _relativePath: notFoundPath,\n    _level: 0,\n  };\n  authInputRoutes.push(notFoundPage);\n  flattenRoutes.push(notFoundPage);\n}\n\n// determine whether it is a react component\n// react Components are characterized by functions\n\nexport function isComponent (component: any): component is React.ComponentType<any> {\n  if (component instanceof Function) {\n    return true;\n  }\n  return false;\n}\n\nexport function isString (str: any): str is string {\n  if (typeof str === 'string') {\n    return true;\n  }\n  return false;\n}\n\n/**\n * 1、To support ts, users are prompted when writing code\n * 2、Modify global configuration\n * 3、Add '_isDefined' attribute, Used by MRouter to defined whether the object has been called defineRouterConfig\n * @param routerConfig\n * @returnsRouterBaseConfigI\n */\nlet _defineId = 0;\nexport function defineRouterConfig (routerConfig: RouterConfigI): RouterBaseConfigI {\n  const { LoadingComponent, ..._config } = routerConfig;\n  _defineId = _defineId + 1;\n  if (LoadingComponent) {\n    setChangeable({LoadingComponent})\n  }\n  /** add '_isDefined' attribute */\n  const config: RouterBaseConfigI = {..._config, _isDefined: true, _defineId: _defineId}\n  return config;\n}\n\ninterface ArrayLike<T> extends Array<T> {\n  readonly length: number\n  readonly [n: number]: T\n}\ntype Many<T> = T | ReadonlyArray<T>;\n\nexport function flattenArr<T> (ary: ArrayLike<Many<T>> | null | undefined): T[] {\n  if (!ary) {\n    return [];\n  }\n  return ary.reduce((pre: T[], cur) => {\n    return pre.concat(Array.isArray(cur) ? flattenArr(cur) : cur);\n  }, [] as T[]);\n}\n\n\n","import * as React from 'react';\nimport NoAuth from '../NoAuth';\n\nconst NotFound: React.FC = () => {\n  return <NoAuth code=\"404\" />;\n};\n\nexport default NotFound;\n","import { NewStateI, NewStateQueryI } from \"./type\";\nimport { computedNewState } from \"./util\";\n\n// Initialized data to prevent double calculation\n// defineRouterConfig may be called multiple times in the same application\nlet initialStateMap = new Map<\n  number,\n  {\n    queryData: NewStateQueryI;\n    initialData: NewStateI;\n  }\n>();\n\nfunction getSameQueryData(\n  prevData: NewStateQueryI,\n  currentData: NewStateQueryI\n) {\n  return (\n    prevData.basename === currentData.basename &&\n    prevData.hasAuth === currentData.hasAuth &&\n    prevData.beforeEachMount === currentData.beforeEachMount &&\n    prevData.inputRoutes === currentData.inputRoutes && \n    prevData.permissionList === currentData.permissionList\n  );\n}\nfunction getInitialState(\n  currentQueryData: NewStateQueryI & { _defineId: number }\n): NewStateI {\n  const {\n    inputRoutes,\n    hasAuth,\n    permissionList,\n    beforeEachMount,\n    basename,\n    location,\n    _defineId\n  } = currentQueryData;\n  const prevData = initialStateMap.get(_defineId);\n  if (prevData) {\n    const isSameQueryData = getSameQueryData(\n      prevData.queryData,\n      currentQueryData\n    );\n    if (isSameQueryData) {\n      return prevData.initialData;\n    }\n  }\n  const _initialState = computedNewState({\n    inputRoutes,\n    permissionList,\n    hasAuth,\n    beforeEachMount,\n    basename,\n    location\n  });\n  initialStateMap.set(_defineId, {\n    queryData: currentQueryData,\n    initialData: _initialState\n  });\n  return _initialState;\n}\n\nexport default getInitialState;\n","import * as React from 'react';\nimport type { RouteHistoryObject } from '../type';\n\nconst MRouterHistoryContext = React.createContext<RouteHistoryObject>(null!);\nMRouterHistoryContext.displayName = 'MRouterHistoryContext';\n\nexport function useHistory () {\n  return React.useContext(MRouterHistoryContext).history;\n}\n\nexport function useRouteHooks () {\n  return React.useContext(MRouterHistoryContext).routeHooks;\n}\n\nexport function useRouteHooksRef () {\n  return React.useContext(MRouterHistoryContext).routeHooksRef;\n}\n\nexport function useHistoryMethods () {\n  return React.useContext(MRouterHistoryContext).historyMethods;\n}\n\nexport default MRouterHistoryContext;\n","import * as React from \"react\";\nimport { useMemo } from \"react\";\nimport { unstable_batchedUpdates } from \"react-dom\";\nimport type { BrowserRouterProps, Location } from \"react-router-dom\";\nimport { Router } from \"react-router-dom\";\nimport type { BrowserHistory } from \"@remix-run/router\";\nimport { createBrowserHistory } from \"@remix-run/router\";\nimport type { RouteCbI, RouteHistoryObject } from \"./type\";\nimport MRouterHistoryContext from \"./Context/MRouterHistoryContext\";\n\n/**\n * A `<Router>` for use in web browsers. Provides the cleanest URLs.\n */\nexport default function BrowserRouter({\n  basename,\n  children,\n  syncUpdateCurrentRoute\n}: BrowserRouterProps & {\n  syncUpdateCurrentRoute: (location: Location) => void;\n}) {\n  const historyRef = React.useRef<BrowserHistory>(null!);\n  const routeHooksRef = React.useRef<RouteCbI[]>(null!);\n  if (historyRef.current == null) {\n    historyRef.current = createBrowserHistory({ window });\n    routeHooksRef.current = [];\n  }\n\n  const historyContext = useMemo(() => {\n    return {\n      history: historyRef.current as BrowserHistory,\n      routeHooks: routeHooksRef.current as RouteCbI[],\n      routeHooksRef,\n      historyMethods: {\n        push: historyRef.current.push,\n        replace: historyRef.current.replace,\n        go: historyRef.current.go\n      }\n    } as RouteHistoryObject;\n  }, []);\n\n  const history = historyRef.current;\n\n  const [state, setState] = React.useState({\n    action: history.action,\n    location: history.location\n  });\n\n  React.useLayoutEffect(() => {\n    let mounted = true;\n    history.listen(routeData => {\n      const { location } = routeData;\n      if (!mounted) {\n        return;\n      }\n      unstable_batchedUpdates(() => {\n        setState(routeData);\n        syncUpdateCurrentRoute(location);\n      });\n    });\n    return () => {\n      mounted = false;\n    };\n  }, [history, syncUpdateCurrentRoute]);\n  return (\n    <MRouterHistoryContext.Provider value={historyContext}>\n      <Router\n        basename={basename}\n        location={state.location}\n        navigationType={state.action}\n        navigator={history}\n      >\n        {children}\n      </Router>\n    </MRouterHistoryContext.Provider>\n  );\n}\n","import * as React from \"react\";\nimport { useMemo } from \"react\";\nimport { unstable_batchedUpdates } from \"react-dom\";\nimport type { BrowserRouterProps, Location } from \"react-router-dom\";\nimport { Router } from \"react-router-dom\";\nimport { HashHistory, createHashHistory } from \"@remix-run/router\";\nimport type { RouteCbI, RouteHistoryObject } from \"./type\";\nimport MRouterHistoryContext from \"./Context/MRouterHistoryContext\";\n\n/**\n * A `<Router>` for use in web browsers. Provides the cleanest URLs.\n */\nexport default function HashRouter({\n  basename,\n  children,\n  syncUpdateCurrentRoute\n}: BrowserRouterProps & {\n  syncUpdateCurrentRoute: (location: Location) => void;\n}) {\n  const historyRef = React.useRef<HashHistory>(null!);\n  const routeHooksRef = React.useRef<RouteCbI[]>(null!);\n  if (historyRef.current == null) {\n    historyRef.current = createHashHistory({ window });\n    routeHooksRef.current = [];\n  }\n  const historyContext = useMemo(() => {\n    return {\n      history: historyRef.current as HashHistory,\n      routeHooks: routeHooksRef.current as RouteCbI[],\n      routeHooksRef,\n      historyMethods: {\n        push: historyRef.current.push,\n        replace: historyRef.current.replace,\n        go: historyRef.current.go\n      }\n    } as RouteHistoryObject;\n  }, []);\n\n  const history = historyRef.current;\n\n  const [state, setState] = React.useState({\n    action: history.action,\n    location: history.location\n  });\n\n  React.useLayoutEffect(() => {\n    let mounted = true;\n    history.listen(routeData => {\n      const { location } = routeData;\n      if (!mounted) {\n        return;\n      }\n      unstable_batchedUpdates(() => {\n        setState(routeData);\n        syncUpdateCurrentRoute(location);\n      });\n    });\n    return () => {\n      mounted = false;\n    };\n  }, [history, syncUpdateCurrentRoute]);\n  return (\n    <MRouterHistoryContext.Provider value={historyContext}>\n      <Router\n        basename={basename}\n        location={state.location}\n        navigationType={state.action}\n        navigator={history}\n      >\n        {children}\n      </Router>\n    </MRouterHistoryContext.Provider>\n  );\n}\n","import type { NavigateOptions, To } from \"react-router-dom\";\nimport type { ParsedQuery } from \"query-string\";\nimport type { BrowserHistory, Location } from \"history\";\nimport * as React from \"react\";\n\nexport interface RouterBaseConfigI {\n  routes: RouteTypeI[];\n  basename?: string;\n  beforeEachMount?: BeforeEachMountI;\n  // the title of the document changes depending on the route switch\n  autoDocumentTitle?:\n    | boolean\n    | ((currentPathRoutes: RouteTypeExtendsI[]) => string);\n  _isDefined: boolean; // 是否是defined的\n  _defineId: number;\n}\n\nexport interface RouterConfigI extends Omit<RouterBaseConfigI, \"_isDefined\"> {\n  /** Lazy component or before next called */\n  LoadingComponent?: React.FunctionComponent<any>;\n  // beforeEachEnter?: BeforeEachEnterI;\n}\n\nexport type PermissionListType = string[];\nexport type CodeType = string | string[] | FnCodeType;\nexport type FnCodeType = (route: RouteTypeI) => boolean;\n\nexport type NextOptionsType =\n  | {\n      name?: string; // if name is configured, it will jump to the route corresponding to the route configuration\n      path?: string; // path\n    }\n  | React.ComponentType<any>; // iff a component is configured, it will be rendered\n\n// global route entry hook\nexport interface BeforeEachMountI {\n  (to: RouteTypeI, next: (nextOptionsType?: NextOptionsType) => void): void;\n}\n\nexport interface BeforeEachEnterI {\n  (to: RouteTypeI, next: (nextOptionsType?: NextOptionsType) => void): void;\n}\n\nexport enum RouteNavTypeEnum {\n  menu,\n  step\n}\nexport interface BeforeEnterI {\n  (\n    to: RouteTypeI | undefined,\n    next: (nextOptionsType?: NextOptionsType) => void\n  ): void;\n}\n\nexport interface BeforeLeaveI {\n  (\n    to: RouteTypeI | undefined,\n    from: RouteTypeI | undefined,\n    next: (ReplaceComponent?: any) => void\n  ): void;\n}\nexport interface RouteTypePropsI {\n  beforeEachMount?: BeforeEachMountI;\n  beforeEnter?: BeforeEnterI;\n  [prop: string]: any;\n}\n\nexport type RouteComponentType = React.LazyExoticComponent<any> | React.FC<any>;\nexport interface RouteTypeI {\n  name: string;\n  path: string;\n  component?: RouteComponentType;\n\n  beforeEnter?: BeforeEnterI;\n  beforeLeave?: BeforeLeaveI;\n  items?: RouteTypeI[]; // same level route\n  children?: RouteTypeI[]; // sub route of multi-level route, such as level-2 route under level-1 route\n  title?: string;\n  hidden?: boolean;\n  icon?: string;\n  code?: CodeType; // each menu item has a code, and the route code of the same menu item is the same\n  parentName?: string; // parent route name\n  fullscreen?: boolean; // if is true, the navigation bar will be hidden\n  props?: RouteTypePropsI;\n  redirect?: string;\n  type?: \"real\" | \"null\";\n\n  meta?: Record<string, any>; // some other information can be customized\n}\n\nexport interface RouteTypeInputI extends RouteTypeI {\n  _relativePath: string;\n  _level: number;\n  items?: RouteTypeInputI[];\n  children?: RouteTypeInputI[];\n  parent?: RouteTypeInputI;\n}\n\nexport interface RouteTypeExtendsI extends RouteTypeInputI {\n  parent?: RouteTypeExtendsI; // parent route name\n\n  meta: Record<string, any>; // some other information can be customized\n  items?: RouteTypeExtendsI[];\n  children?: RouteTypeExtendsI[];\n  _route?: RouteTypeInputI;\n  _component?: RouteComponentType;\n  _isHasAuth?: boolean; // true has permission; false: no permission\n  _itemsAndChildren?: RouteTypeExtendsI[];\n}\n\nexport enum RouterActionEnum {\n  UPDATE_INPUT_ROUTES = \"UPDATE_INPUT_ROUTES\",\n  UPDATE_CURRENT_ROUTE = \"UPDATE_CURRENT_ROUTE\",\n  UPDATE_STATE = \"UPDATE_STATE\",\n  ADD_ROUTES = \"ADD_ROUTES\",\n  REMOVE_ROUTES = \"REMOVE_ROUTES\",\n  UPDATE_ROUTES = \"UPDATE_ROUTES\"\n}\nexport interface Action {\n  type: RouterActionEnum;\n  payload?: any;\n  dispatch?: React.Dispatch<Action>;\n}\n\nexport interface MRouterStateI {\n  basename: string;\n\n  inputRoutes: RouteTypeInputI[];\n  authInputRoutes: RouteTypeExtendsI[];\n\n  routesMap: RoutesMapI;\n  flattenRoutes: RouteTypeExtendsI[];\n  currentRoute: RouteTypeExtendsI;\n  currentPathRoutes: RouteTypeExtendsI[];\n  prevRoute?: RouteTypeExtendsI;\n  permissionList?: string[];\n  hasAuth?: boolean;\n\n  beforeEachMount?: BeforeEachMountI;\n\n  _getNewStateByNewInputRoutes: (\n    _inputRoutes: RouteTypeInputI[]\n  ) => NewStateI;\n}\n\nexport interface AddRoutesI {\n  (routes: RouteTypeI[]): void;\n}\nexport interface RemoveRoutesI {\n  (routeNames: string[]): void;\n}\nexport interface UpdateRoutesI {\n  (routes: { routeName: string; routeData: Partial<RouteTypeI> }[]): void;\n}\nexport interface MRouterMethodsI {\n  addRoutes: AddRoutesI;\n  updateCurrentRoute: (currentRoute: RouteTypeExtendsI) => void;\n  removeRoutes: RemoveRoutesI;\n  updateRoutes: UpdateRoutesI;\n  // getStateByInputRoutes: (inputRoutes: RouteTypeInputI[]) => NewStateI;\n  [method: string]: any;\n}\nexport interface MRouterContextObject {\n  state: MRouterStateI;\n  // Some operation methods\n  methods: MRouterMethodsI;\n}\n\nexport interface RoutesBaseStateStruct {\n  routesMap: RoutesMapI;\n  routes: RouteTypeI[];\n  // flat routing\n  flattenRoutes: RouteTypeI[];\n  basename?: string;\n}\nexport interface ExtraNavigateOptions extends NavigateOptions {\n  params?: Record<string, any>; // url parameters of the route, for example: id\n  query?: Record<string, any>; // url query\n}\nexport interface NavigateFunction {\n  (to: To, options?: ExtraNavigateOptions): void;\n  (delta: number): void;\n}\nexport interface RoutesStateStruct extends RoutesBaseStateStruct {\n  navigate: NavigateFunction;\n  location: Location;\n  currentRoute: RouteTypeExtendsI;\n  authRoutes: RouteTypeExtendsI[];\n  query: ParsedQuery<string>;\n  params: Record<string, number | string>;\n}\n\nexport type RouteEvent = \"BeforeRouterLeave\" | \"AfterRouterEnter\";\n\nexport interface RouteCbI {\n  fn: BeforeLeaveI;\n  name: RouteEvent;\n  pathname: string;\n}\n\nexport interface RouteConfig {\n  path: string;\n  element?: React.ReactNode;\n  children?: RouteConfig[];\n}\n\nexport interface RouteHistoryObject {\n  history: BrowserHistory;\n  historyMethods: {\n    push(to: To, state?: any): void;\n    replace(to: To, state?: any): void;\n    go(delta: number): void;\n    back(): void;\n    forward(): void;\n  };\n  routeHooks: RouteCbI[];\n  routeHooksRef: React.MutableRefObject<RouteCbI[]>;\n}\nexport interface BaseRoutesMapI extends Record<string, RouteTypeExtendsI> {}\n\nexport type RoutesMapI = BaseRoutesMapI & {\n  __paramsRoutesMap: Record<string, RouteTypeExtendsI>;\n  __flattenRoutes: RouteTypeExtendsI[];\n};\n\nexport interface NewStateQueryI {\n  inputRoutes: RouteTypeInputI[];\n  permissionList?: string[];\n  hasAuth: boolean;\n  beforeEachMount?: BeforeEachMountI;\n  basename: string;\n  location: Location;\n}\n\nexport interface NewStateI {\n  authInputRoutes: RouteTypeExtendsI[];\n  flattenRoutes: RouteTypeExtendsI[];\n  routesMap: RoutesMapI;\n  currentRoute: RouteTypeExtendsI;\n  currentPathRoutes: RouteTypeExtendsI[];\n  beforeEachMount?: BeforeEachMountI | undefined;\n}\n","import type {\n  RouteTypeI,\n  MRouterStateI,\n  RouteTypeInputI,\n} from \"./type\";\nimport { cloneRoutes, computedNewState } from \"./util\";\n\nfunction newInputRoutesState(inputRoutes?: RouteTypeInputI[]): {\n  inputRoutes: RouteTypeInputI[];\n  routesMap: Record<string, RouteTypeInputI>;\n} {\n  const routesMap: Record<string, RouteTypeInputI> = {};\n  function _cloneInputRoutes(\n    inputRoutes?: RouteTypeInputI[],\n    parent?: RouteTypeInputI\n  ): RouteTypeInputI[] {\n    if (!inputRoutes) {\n      return [];\n    }\n    return inputRoutes.map(i => {\n      const _route: RouteTypeInputI = {\n        ...i,\n        items: [],\n        children: [],\n        parent: parent\n      };\n      _route.items = _cloneInputRoutes(i.items, _route);\n      _route.children = _cloneInputRoutes(i.children, _route);\n      routesMap[i.name] = _route;\n      return _route;\n    }, []);\n  }\n  return {\n    inputRoutes: _cloneInputRoutes(inputRoutes),\n    routesMap: routesMap\n  };\n}\n\n/**\n * add routes operation\n * @param state MRouterStateI\n * @param payload RouteTypeI[]\n * @returns MRouterStateI\n */\nexport function addRoutesAction(\n  state: MRouterStateI,\n  payload: any\n): MRouterStateI {\n  let hasChange = false;\n  const newRoutes = payload as RouteTypeI[];\n  const { routesMap, inputRoutes } = newInputRoutesState(state.inputRoutes);\n\n  newRoutes.forEach(_route => {\n    const { path, name, parentName } = _route;\n\n    if (routesMap[path] || routesMap[name]) {\n      throw new Error(`新增路由 ${name} ${path} 已经存在，请修改`);\n    }\n\n    if (parentName) {\n      const _parentRoute = routesMap[parentName];\n      if (_parentRoute) {\n        const route = cloneRoutes({\n          routes: [_route],\n          parent: _parentRoute,\n          _level: _parentRoute._level! + 1\n        });\n        _parentRoute.items = _parentRoute.items || [];\n        _parentRoute.items.push(route[0]);\n        hasChange = true;\n      }\n    } else {\n      // 根路径插入\n      const route = cloneRoutes({\n        routes: [_route],\n        _level: 0\n      });\n      inputRoutes.push(route[0]);\n      hasChange = true;\n    }\n  });\n  if (hasChange) {\n    const newState = state._getNewStateByNewInputRoutes(inputRoutes);\n\n    return {\n      ...state,\n      ...newState,\n      inputRoutes: [...inputRoutes]\n    };\n  }\n  return state;\n}\n/**\n * update routes operation\n * @param state MRouterStateI\n * @param payload RouteTypeI[]\n * @returns MRouterStateI\n */\nexport function updateRoutesAction(\n  state: MRouterStateI,\n  payload: any\n): MRouterStateI {\n  let hasChange = false;\n  // const { basename } = state;\n  const newRoutesPayload = payload as {\n    routeName: string;\n    routeData: Partial<RouteTypeI>;\n  }[];\n  const { routesMap, inputRoutes } = newInputRoutesState(state.inputRoutes);\n  newRoutesPayload.forEach(({ routeName, routeData }) => {\n    const route = routesMap[routeName];\n    if (route) {\n      // 如果parent存在，则不是根节点\n      const parent = route.parent;\n\n      const _newRouteData = {\n        ...route,\n        ...routeData\n      };\n\n      const newRouteData = cloneRoutes({\n        routes: [_newRouteData],\n        parent,\n        _level: (parent?._level || 0) + 1,\n        basename: state.basename\n      });\n\n      if (!parent) {\n        Object.assign(route, newRouteData[0]);\n        hasChange = true;\n      }\n      if (parent && parent.items) {\n        parent.items.splice(parent.items.indexOf(route), 1, newRouteData[0]);\n        hasChange = true;\n      } else if (parent && parent.children) {\n        parent.children.splice(\n          parent.children.indexOf(route),\n          1,\n          newRouteData[0]\n        );\n        hasChange = true;\n      }\n    }\n  });\n\n  if (hasChange) {\n    const newState = state._getNewStateByNewInputRoutes(inputRoutes);\n    return {\n      ...state,\n      ...newState,\n      inputRoutes: [...inputRoutes]\n    };\n  }\n  return state;\n}\n/**\n * remove routes operation\n * @param state MRouterStateI\n * @param payload RouteTypeI[]\n * @returns MRouterStateI\n */\nexport function removeRoutesAction(\n  state: MRouterStateI,\n  payload: any\n): MRouterStateI {\n  let hasChange = false;\n  const routeNames = payload as string[];\n  const { routesMap, inputRoutes } = newInputRoutesState(state.inputRoutes);\n  routeNames.forEach(routeName => {\n    const _route = routesMap[routeName];\n    if (_route) {\n      // 如果parent存在，则不是根节点\n      const parent = _route.parent;\n      if (!parent) {\n        const index = inputRoutes.indexOf(_route);\n        if (index > -1) {\n          inputRoutes.splice(index, 1);\n          hasChange = true;\n        }\n      }\n      if (parent && parent.items) {\n        const index = parent.items.indexOf(_route);\n        if (index > -1) {\n          parent.items.splice(index, 1);\n          hasChange = true;\n        }\n      }\n    }\n  });\n  if (hasChange) {\n    const newState = state._getNewStateByNewInputRoutes(inputRoutes);\n    return {\n      ...state,\n      ...newState,\n      inputRoutes: [...inputRoutes]\n    };\n  } else {\n    return state;\n  }\n}\n","import * as React from 'react';\nimport { addRoutesAction, removeRoutesAction, updateRoutesAction } from '../actions';\nimport type {\n  Action,\n  AddRoutesI,\n  RoutesMapI,\n  UpdateRoutesI,\n  MRouterContextObject,\n  MRouterStateI,\n} from '../type';\nimport {\n  RouterActionEnum\n} from '../type';\n\nconst MRouterContext = React.createContext<MRouterContextObject>({\n  state: {\n    inputRoutes: [],\n    authInputRoutes: [],\n    permissionList: [],\n    routesMap: {} as RoutesMapI,\n    flattenRoutes: [],\n  },\n  methods: {},\n} as unknown as MRouterContextObject);\nMRouterContext.displayName = 'MRouterContext';\n\nexport function MRouterReducer (state: MRouterStateI, action: Action): MRouterStateI {\n  const { type, payload } = action;\n  switch (type) {\n    case RouterActionEnum.ADD_ROUTES: {\n      return addRoutesAction(state, payload);\n    }\n    case RouterActionEnum.REMOVE_ROUTES: {\n      return removeRoutesAction(state, payload);\n    }\n    case RouterActionEnum.UPDATE_ROUTES: {\n      return updateRoutesAction(state, payload);\n    }\n    case RouterActionEnum.UPDATE_INPUT_ROUTES: {\n      return {\n        ...state,\n        inputRoutes: payload,\n      };\n    }\n    case RouterActionEnum.UPDATE_CURRENT_ROUTE: {\n      return {\n        ...state,\n        currentRoute: payload,\n      };\n    }\n    case RouterActionEnum.UPDATE_STATE: {\n      return {\n        ...state,\n        ...payload,\n      };\n    }\n    default: {\n      return { ...state };\n    }\n  }\n}\n\nexport function useRouterState (): MRouterStateI {\n  return React.useContext(MRouterContext).state;\n}\n\n/** Dynamically add routing method */\nexport function useAddRoutes (): AddRoutesI {\n  return React.useContext(MRouterContext).methods.addRoutes;\n}\n\nexport function useRemoveRoutes (): (routeNames: string[]) => void {\n  return React.useContext(MRouterContext).methods.removeRoutes;\n}\n\nexport function useUpdateRoutes (): UpdateRoutesI {\n  return React.useContext(MRouterContext).methods.updateRoutes;\n}\n\nexport default MRouterContext;\n","import * as React from 'react';\nimport {\n  Suspense,\n  useCallback,\n  useEffect,\n  useImperativeHandle,\n  useLayoutEffect,\n  useMemo,\n  useReducer,\n  useRef,\n  useState\n} from \"react\";\nimport type { Location, To } from \"react-router-dom\";\nimport {\n  generatePath,\n  useLocation,\n  useNavigate as useOldNavigate,\n  useParams,\n  useRoutes\n} from \"react-router\";\nimport { parse, stringify } from \"query-string\";\n\nimport {\n  cloneRoutes,\n  computedNewState,\n  executeEventCbs,\n  flattenArr,\n  getCurrentPathRoutes,\n  getCurrentRoute,\n  getCurrentRouteCbsByEvent,\n  getRealTo\n} from \"./util\";\nimport getInitialState from \"./getInitialState\";\nimport BrowserRouter from \"./BrowserRouter\";\nimport HashRouter from \"./HashRouter\";\nimport type {\n  BeforeLeaveI,\n  ExtraNavigateOptions,\n  RouteCbI,\n  RouteConfig,\n  RouteTypeExtendsI,\n  RouteTypeI,\n  RoutesMapI,\n  RoutesStateStruct,\n  RouterBaseConfigI,\n  RouteTypeInputI,\n  NewStateI\n} from \"./type\";\nimport { RouterActionEnum } from \"./type\";\nimport MRouterContext, {\n  MRouterReducer,\n  useAddRoutes,\n  useRemoveRoutes,\n  useRouterState,\n  useUpdateRoutes\n} from \"./Context/MRouterContext\";\nimport {\n  useHistory,\n  useHistoryMethods,\n  useRouteHooksRef\n} from \"./Context/MRouterHistoryContext\";\nimport { changeable } from \"./changeable\";\n\nexport type { RouterConfigI, RouteTypeI, RouteTypeExtendsI } from \"./type\";\n\nexport { defineRouterConfig } from \"./util\";\n\nconst DEFAULT_PERMISSION_LIST: string[] = [];\n\nfunction useBeforeLeave(fn: BeforeLeaveI): void {\n  const pathname = window.location.pathname;\n  const routeHooksRef = useRouteHooksRef();\n  useLayoutEffect(() => {\n    const hooks = routeHooksRef.current;\n    const routeHook = {\n      name: \"BeforeRouterLeave\",\n      pathname,\n      fn\n    } as RouteCbI;\n    hooks.push(routeHook);\n    return () => {\n      const index = hooks.indexOf(routeHook);\n      hooks.splice(index, 1);\n    };\n  }, [fn, pathname, routeHooksRef]);\n}\nexport interface NavigateFunction {\n  (to: To, options?: ExtraNavigateOptions): void;\n  (delta: number): void;\n}\n\nconst useNavigate = (): NavigateFunction => {\n  const oldNavigate = useOldNavigate();\n  const newCallback = useCallback(\n    (to, options: ExtraNavigateOptions = {}) => {\n      if (options?.params && typeof to === \"string\") {\n        to = generatePath(to, options.params);\n      }\n      // query写入地址栏\n      if (options?.query && typeof to === \"string\") {\n        let path = to;\n        const queryStr = stringify(options.query);\n        if (path.includes(\"?\")) {\n          path = `${path}&${queryStr}`;\n        } else {\n          path = `${path}?${queryStr}`;\n        }\n        to = path;\n      }\n\n      return oldNavigate(to, options);\n    },\n    [oldNavigate]\n  );\n  return newCallback;\n};\n\nfunction useRouter(): RoutesStateStruct {\n  const location = useLocation();\n  const routesMapRef = useRef<RoutesMapI>({} as RoutesMapI);\n  const {\n    routesMap,\n    inputRoutes,\n    currentRoute,\n    flattenRoutes,\n    authInputRoutes,\n    basename\n  } = useRouterState();\n\n  if (routesMapRef.current !== routesMap) {\n    routesMapRef.current = routesMap;\n  }\n\n  const search = useMemo(() => {\n    return parse(location.search);\n  }, [location.search]);\n\n  const routerParams = useParams();\n\n  const newNavigate = useNavigate();\n\n  return {\n    navigate: newNavigate,\n    routesMap,\n    query: search,\n    params: routerParams as Record<string, string | number>,\n    routes: inputRoutes,\n    authRoutes: authInputRoutes,\n    currentRoute,\n    flattenRoutes,\n    location,\n    basename\n  };\n}\n\ninterface MRouterContextProviderI {\n  permissionList?: string[];\n  hasAuth: boolean;\n  routerConfig: RouterBaseConfigI;\n  children?: (children: React.ReactNode) => React.ReactNode;\n}\n\ninterface InternalMRouterContextProviderRef {\n  updateCurrentRoute: (location: Location) => void;\n}\n\nconst InternalMRouterContextProvider: React.ForwardRefRenderFunction<\n  InternalMRouterContextProviderRef,\n  MRouterContextProviderI\n> = (\n  { permissionList = DEFAULT_PERMISSION_LIST, routerConfig, hasAuth, children },\n  ref\n) => {\n  const history = useHistory();\n  const location = useLocation();\n  const locationRef = useRef(location);\n\n  const oldHistoryMethods = useHistoryMethods();\n  const routeHooksRef = useRouteHooksRef();\n\n  const {\n    routes = [],\n    basename = \"/\",\n    beforeEachMount,\n    autoDocumentTitle = false\n  } = routerConfig;\n\n  const inputRoutes = useMemo(() => {\n    return cloneRoutes({\n      routes,\n      basename\n    });\n  }, [basename, routes]);\n\n  const inputRoutesRef = useRef(inputRoutes);\n\n  const [initialState] = useState(\n    getInitialState({\n      inputRoutes,\n      permissionList,\n      hasAuth,\n      beforeEachMount,\n      basename,\n      location: locationRef.current,\n      _defineId: routerConfig._defineId\n    })\n  );\n\n  const getNewStateByNewInputRoutesRef = useRef<\n    (_inputRoutes: RouteTypeInputI[]) => NewStateI\n  >(null!);\n  const _getNewStateByNewInputRoutes = useCallback(\n    (_inputRoutes: RouteTypeInputI[]) => {\n      return computedNewState({\n        inputRoutes: _inputRoutes,\n        permissionList,\n        hasAuth,\n        beforeEachMount,\n        basename,\n        location: location\n      });\n    },\n    [basename, beforeEachMount, hasAuth, location, permissionList]\n  );\n  getNewStateByNewInputRoutesRef.current = _getNewStateByNewInputRoutes;\n\n  // initialization\n  const [state, dispatch] = useReducer(MRouterReducer, {\n    ...initialState,\n    inputRoutes,\n    permissionList,\n    hasAuth,\n    basename,\n    _getNewStateByNewInputRoutes: getNewStateByNewInputRoutesRef.current\n  });\n\n  /**\n   * listen router change，set currentRoute\n   *  Put the updated currentRoute in history listen updates in batches to reduce the number of updates\n   */\n  useImperativeHandle(ref, () => {\n    return {\n      updateCurrentRoute(location) {\n        const { pathname } = location;\n        const prevRoute = state.currentRoute;\n        const currentRoute = getCurrentRoute(pathname, state.routesMap);\n\n        let currentPathRoutes = state.currentPathRoutes;\n        if (currentRoute !== state.currentRoute) {\n          currentPathRoutes = getCurrentPathRoutes(currentRoute);\n        }\n        dispatch({\n          type: RouterActionEnum.UPDATE_STATE,\n          payload: {\n            currentRoute,\n            currentPathRoutes,\n            prevRoute\n          }\n        });\n      }\n    };\n  });\n\n  useLayoutEffect(() => {\n    // filter routes without permission\n    // used to judge initialization or update. If they are equal, only currentRoute needs to be calculated\n    if (\n      state.permissionList === permissionList &&\n      hasAuth === state.hasAuth &&\n      state.inputRoutes === inputRoutes &&\n      state.beforeEachMount === beforeEachMount\n    ) {\n      return;\n    }\n    // if inputRoutes change, the incoming inputRoutes shall prevail\n    let _inputRoutes = state.inputRoutes;\n    if (\n      inputRoutesRef.current === inputRoutes &&\n      state.permissionList === permissionList &&\n      hasAuth === state.hasAuth &&\n      state.beforeEachMount === beforeEachMount\n    ) {\n      // Equal, indicating that state.inputRoutes has changed, is add remove and update routes\n      return;\n    } else {\n      // if not Equal, record the value of inputRoutes for next comparison\n      inputRoutesRef.current = inputRoutes;\n      _inputRoutes = inputRoutes;\n    }\n\n    const {\n      authInputRoutes,\n      flattenRoutes,\n      routesMap,\n      currentRoute,\n      currentPathRoutes\n    } = computedNewState({\n      inputRoutes: _inputRoutes,\n      permissionList,\n      hasAuth,\n      beforeEachMount,\n      basename,\n      location\n    });\n\n    dispatch({\n      type: RouterActionEnum.UPDATE_STATE,\n      payload: {\n        permissionList,\n        authInputRoutes,\n        routesMap,\n        flattenRoutes,\n        currentRoute,\n        currentPathRoutes,\n        basename,\n        beforeEachMount\n      }\n    });\n  }, [\n    state.inputRoutes,\n    inputRoutes,\n    permissionList,\n    state.permissionList,\n    hasAuth,\n    state.hasAuth,\n    basename,\n    beforeEachMount,\n    location\n  ]);\n\n  // auto setting document.title\n  useEffect(() => {\n    if (!autoDocumentTitle) {\n      return;\n    }\n    let title = \"\";\n    if (typeof autoDocumentTitle === \"boolean\") {\n      title = state.currentPathRoutes\n        .map(i => {\n          return i.title;\n        })\n        .join(\"-\");\n    } else if (typeof autoDocumentTitle === \"function\") {\n      title = autoDocumentTitle(state.currentPathRoutes);\n    }\n    document.title = title;\n  }, [autoDocumentTitle, state.currentPathRoutes]);\n\n  const allExecuteEventCbs = useCallback(\n    (historyCb: () => void, to?: To) => {\n      if (typeof to !== \"string\") {\n        to = to?.pathname;\n      }\n      const pathname = window.location.pathname;\n      const beforeRouterLeaveCbs = getCurrentRouteCbsByEvent(\n        \"BeforeRouterLeave\",\n        pathname,\n        routeHooksRef.current\n      );\n      if (state.currentRoute?.beforeLeave) {\n        beforeRouterLeaveCbs.unshift({\n          name: \"BeforeRouterLeave\",\n          pathname: state.currentRoute.path,\n          fn: state.currentRoute.beforeLeave as BeforeLeaveI\n        });\n      }\n      if (beforeRouterLeaveCbs.length) {\n        executeEventCbs({\n          to: getCurrentRoute(to as string, state.routesMap),\n          from: getCurrentRoute(pathname, state.routesMap),\n          callbacks: beforeRouterLeaveCbs,\n          finish: () => {\n            return historyCb();\n          }\n        });\n      } else {\n        return historyCb();\n      }\n    },\n    [\n      routeHooksRef,\n      state.currentRoute.beforeLeave,\n      state.currentRoute.path,\n      state.routesMap\n    ]\n  );\n\n  useLayoutEffect(() => {\n    // Intercept the methods used in history in useNavigator\n    history.go = (delta: number) => {\n      allExecuteEventCbs(() => {\n        const res = oldHistoryMethods.go(delta);\n        // history.go = oldHistoryMethods.go;\n        return res;\n      });\n    };\n    history.push = (to: To, state?: any) => {\n      to = getRealTo(to);\n      allExecuteEventCbs(() => {\n        const res = oldHistoryMethods.push(to, state);\n        // history.push = oldHistoryMethods.push;\n        return res;\n      }, to);\n    };\n\n    history.replace = (to: To, state?: any) => {\n      to = getRealTo(to);\n      allExecuteEventCbs(() => {\n        const res = oldHistoryMethods.replace(to, state);\n        // history.replace = oldHistoryMethods.replace;\n        return res;\n      }, to);\n    };\n\n    history.back = () => {\n      allExecuteEventCbs(() => {\n        const res = oldHistoryMethods.back();\n        // history.back = oldHistoryMethods.back;\n        return res;\n      });\n    };\n\n    history.forward = () => {\n      allExecuteEventCbs(() => {\n        const res = oldHistoryMethods.forward();\n        // history.forward = oldHistoryMethods.forward;\n        return res;\n      });\n    };\n  }, [allExecuteEventCbs, history, oldHistoryMethods]);\n\n  const addRoutes = useCallback((newRoutes: RouteTypeI[]) => {\n    dispatch({\n      type: RouterActionEnum.ADD_ROUTES,\n      payload: newRoutes\n    });\n  }, []);\n\n  const removeRoutes = useCallback((routeNames: string[]) => {\n    dispatch({\n      type: RouterActionEnum.REMOVE_ROUTES,\n      payload: routeNames\n    });\n  }, []);\n\n  const updateRoutes = useCallback(\n    (routes: { routeName: string; routeData: Partial<RouteTypeI> }[]) => {\n      dispatch({\n        type: RouterActionEnum.UPDATE_ROUTES,\n        payload: routes\n      });\n    },\n    []\n  );\n\n  const updateCurrentRoute = useCallback((currentRoute: RouteTypeExtendsI) => {\n    if (!currentRoute) {\n      return;\n    }\n    dispatch({\n      type: RouterActionEnum.UPDATE_CURRENT_ROUTE,\n      payload: currentRoute\n    });\n  }, []);\n\n  const routesConfig = useMemo(() => {\n    function _computeRoutesConfig(routes: RouteTypeExtendsI[]) {\n      const _routes = routes.map(route => {\n        let _routeConfig: RouteConfig | undefined;\n        let _itemsRouteConfig: RouteConfig[] = [];\n        const {\n          _component: Component,\n          path,\n          items,\n          children,\n          _isHasAuth,\n          props\n        } = route;\n        if (Component) {\n          const LoadingCmp = changeable.LoadingComponent;\n          if (!_isHasAuth) {\n            /** Without permission, the child also has no permission */\n            return {\n              path: path.endsWith(\"*\") ? path : `${path}/*`,\n              element: (\n                <Suspense fallback={<LoadingCmp />}>\n                  <Component {...props} />\n                </Suspense>\n              )\n            } as RouteConfig;\n          }\n          _routeConfig = {\n            path,\n            element: (\n              <Suspense fallback={LoadingCmp}>\n                <Component {...props} />\n              </Suspense>\n            )\n          } as RouteConfig;\n          if (children) {\n            _routeConfig.children = _computeRoutesConfig(children);\n          }\n          if (items) {\n            _itemsRouteConfig = _computeRoutesConfig(items);\n          }\n        }\n\n        const nextRoutes = [_routeConfig, ..._itemsRouteConfig].filter(i => {\n          return i !== undefined;\n        }) as RouteConfig[];\n        return nextRoutes;\n      });\n      return flattenArr(_routes);\n    }\n    const _routesConfig = _computeRoutesConfig(state.authInputRoutes);\n    return _routesConfig;\n  }, [state.authInputRoutes]);\n\n  const routesChildren = useRoutes(routesConfig);\n\n  const renders = useMemo(() => {\n    return children ? children(routesChildren) : routesChildren;\n  }, [children, routesChildren]);\n\n  return (\n    <MRouterContext.Provider\n      value={{\n        state,\n        methods: {\n          addRoutes,\n          updateCurrentRoute,\n          removeRoutes,\n          updateRoutes\n        }\n      }}\n    >\n      {renders}\n    </MRouterContext.Provider>\n  );\n};\n\nconst MRouterContextProvider = React.forwardRef(InternalMRouterContextProvider);\n\nMRouterContextProvider.displayName = \"MRouterContextProvider\";\n\ninterface MRouterPropsI {\n  permissionList?: string[];\n  wrapComponent?: React.FunctionComponent<any>;\n  hasAuth?: boolean;\n  routerConfig: RouterBaseConfigI;\n  children?: (children: React.ReactNode) => React.ReactNode;\n}\ninterface CoreRouterPropsI extends MRouterPropsI {\n  RouterComponent: typeof BrowserRouter | typeof HashRouter;\n}\nconst CoreRouter: React.FC<CoreRouterPropsI> = ({\n  permissionList,\n  wrapComponent: WrapComponent,\n  hasAuth = true,\n  routerConfig,\n  children,\n  RouterComponent\n}) => {\n  const syncUpdateCurrentRouteRef = useRef<{\n    updateCurrentRoute: (location: Location) => void;\n  }>(null!);\n  const syncUpdateCurrentRoute = useCallback(location => {\n    syncUpdateCurrentRouteRef.current?.updateCurrentRoute?.(location);\n  }, []);\n\n  if (__DEV__) {\n    /** Determine whether routerConfig has ‘_isDefined’ attribute */\n    if (!routerConfig._isDefined) {\n      console.error(\n        `The routerConfig does not call defineRouterConfig definition, You should use 'const routerConfig = defineRouterConfig({...})'`\n      );\n    }\n    /** Judge incoming 'WrapComponent' and 'children' */\n    if (WrapComponent && children) {\n      console.warn(\n        `MRouter attributes 'children' and 'WrapComponent' are optional attributes. If both exist, children will be used`\n      );\n    }\n    if (children && typeof children !== \"function\") {\n      console.error(\n        'MRoute attributes children needs to be a function, not a function at present  \"%s\"',\n        children\n      );\n    }\n  }\n\n  const _children = useMemo(() => {\n    if (children && typeof children === \"function\") {\n      return children;\n    }\n    if (WrapComponent) {\n      WrapComponent.displayName = \"WrapComponent\";\n      return function wrapComponent(children: React.ReactNode) {\n        return <WrapComponent>{children}</WrapComponent>;\n      };\n    }\n  }, [WrapComponent, children]);\n\n  return (\n    <RouterComponent syncUpdateCurrentRoute={syncUpdateCurrentRoute}>\n      <MRouterContextProvider\n        routerConfig={routerConfig}\n        permissionList={permissionList}\n        hasAuth={hasAuth}\n        ref={syncUpdateCurrentRouteRef}\n      >\n        {_children}\n      </MRouterContextProvider>\n    </RouterComponent>\n  );\n};\n\nconst MRouter: React.FC<MRouterPropsI> = props => {\n  return <CoreRouter {...props} RouterComponent={BrowserRouter} />;\n};\n\nconst MHRouter: React.FC<MRouterPropsI> = props => {\n  return <CoreRouter {...props} RouterComponent={HashRouter} />;\n};\n\nexport {\n  MRouter,\n  MHRouter,\n  useAddRoutes,\n  useRemoveRoutes,\n  useUpdateRoutes,\n  useBeforeLeave,\n  useRouter,\n  useHistory,\n  useNavigate\n};\n"],"names":["PageConfig","title","img","NoAuth","code","config","React","createElement","style","display","justifyContent","alignItems","background","height","flexDirection","borderRadius","alt","width","src","color","lineHeight","textAlign","marginTop","displayName","NameRedirect","name","component","Component","routesMap","currentRoute","useRouter","targetRoute","Fragment","Navigate","to","path","Spin","tip","changeable","LoadingComponent","getComponent","options","ReplaceComponent","Function","isComponent","isString","GeneratorHookCom","beforeEnter","beforeEachMount","CurrentComponent","setCurrentComponent","useState","undefined","useLayoutEffect","isActive","EachReplaceComponent","enterOptions","EnterReplaceComponent","LoadingCmp","NotFound","incrementKey","getIncrementName","getWholePath","basename","parentPath","startsWith","endsWith","slice","cloneRoutes","_routeConfig","routes","parent","_level","_cloneRoutes","_routes","map","_route","items","children","resets","newRoute","getValidPathname","_relativePath","computedNewState","inputRoutes","permissionList","hasAuth","location","authInputRoutes","computeRoutesConfig","flattenRoutes","flattenRoutesFn","notFoundPath","some","notFoundPage","meta","_component","push","mixinNotFoundPage","routesMapFn","getCurrentRoute","pathname","currentPathRoutes","getCurrentPathRoutes","arr","all","reduce","prev","nextRoute","Array","isArray","concat","_routeMap","Error","includes","_path","replace","__paramsRoutesMap","__flattenRoutes","window","paths","Object","keys","pathIndex","length","pathPattern","RegExp","match","i","filter","longerPath","forEach","pathStartMarkTransform","_isHasAuth","pathRoute","unshift","getIsHasAuthByStrCode","getIsHasAuth","route","_code","getIsHasAuthByFnCode","redirect","type","other","_children","_items","props","key","isHasAuth","noAuthItems","hidden","returnRoute","_itemsAndChildren","redirectPath","handleRedirectPath","getRealTo","childRoute","str","_defineId","defineRouterConfig","routerConfig","_config","entries","value","_isDefined","flattenArr","ary","pre","cur","initialStateMap","Map","MRouterHistoryContext","createContext","useHistory","useContext","history","useRouteHooksRef","routeHooksRef","BrowserRouter","syncUpdateCurrentRoute","historyRef","useRef","current","createBrowserHistory","historyContext","useMemo","routeHooks","historyMethods","go","state","setState","action","mounted","listen","routeData","unstable_batchedUpdates","Provider","Router","navigationType","navigator","HashRouter","createHashHistory","RouteNavTypeEnum","RouterActionEnum","newInputRoutesState","_cloneInputRoutes","MRouterContext","methods","MRouterReducer","payload","ADD_ROUTES","hasChange","newRoutes","parentName","_parentRoute","newState","_getNewStateByNewInputRoutes","addRoutesAction","REMOVE_ROUTES","routeNames","routeName","index","indexOf","splice","removeRoutesAction","UPDATE_ROUTES","newRoutesPayload","newRouteData","assign","updateRoutesAction","UPDATE_INPUT_ROUTES","UPDATE_CURRENT_ROUTE","UPDATE_STATE","useAddRoutes","addRoutes","useRemoveRoutes","removeRoutes","useUpdateRoutes","updateRoutes","DEFAULT_PERMISSION_LIST","useBeforeLeave","fn","hooks","routeHook","useLocation","routesMapRef","search","parse","routerParams","useParams","navigate","oldNavigate","useOldNavigate","useCallback","params","generatePath","query","queryStr","stringify","useNavigate","authRoutes","InternalMRouterContextProvider","ref","locationRef","oldHistoryMethods","autoDocumentTitle","inputRoutesRef","initialState","currentQueryData","prevData","get","isSameQueryData","currentData","getSameQueryData","queryData","initialData","_initialState","set","getInitialState","getNewStateByNewInputRoutesRef","_inputRoutes","dispatch","useReducer","useImperativeHandle","updateCurrentRoute","prevRoute","useEffect","join","document","allExecuteEventCbs","historyCb","beforeRouterLeaveCbs","routeEvent","getCurrentRouteCbsByEvent","beforeLeave","option","from","callbacks","finish","executeNextCb","cbIndex","nextCb","executeEventCbs","delta","back","forward","routesConfig","_routesConfig","_computeRoutesConfig","_itemsRouteConfig","element","Suspense","fallback","routesChildren","useRoutes","renders","MRouterContextProvider","forwardRef","CoreRouter","wrapComponent","WrapComponent","RouterComponent","syncUpdateCurrentRouteRef","MRouter","MHRouter"],"mappings":"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"}